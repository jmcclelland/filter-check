#!/usr/bin/python

import smtplib
import sys
import imaplib
import time
import re
import ConfigParser
from email.parser import HeaderParser
from os.path import expanduser
import argparse


def main():
    # Prepare the command line argument parser.
    parser = argparse.ArgumentParser(prog = "filter-check", description='Check deliverability to various mail providers.')
    parser.add_argument('--sendvia', default=None, help='the host to relay the email');
    parser.add_argument('--sendto', default=None, help='the host to send the email');
    parser.add_argument('--quiet', default=None, action="store_true", help='surpress all output, use exit codes only');
    parser.add_argument('--gtube', default=None, action="store_true", help='use spamassassin code to identify the message as spam (for debugging)');
    parser.add_argument('--headers', default=None, action="store_true", help='output full headers');
    parser.add_argument('--sleep', type=float, default=None, help='number of seconds to wait between sending and checking email');
    args = parser.parse_args()

    check = filter_check()
    check.init(args)
    return check.run()

class filter_check:
    # Constants representing where a message is found.
    INBOX = 0
    SPAMBOX = 1
    NOTFOUND = 3
    ERROR = 255

    # Variable holding where the message was found. 
    found = None 

    # Default values go here.
    settings = {
            'sleep': 10,
            'quiet': False,
            'headers': False,
            'gtube': False,
            'subject': 'Meeting next week',
            'msg': "Hi all,\nDon't forget, the next meeting is on Wendesday at 8:00 pm.\n\nSee you there,\njoe",
            'emailfrom': None,
            'sendto': None,
            'sendvia': None,
            'emailto': None,
            'imap_user': None,
            'imap_pass': None,
            'imap_host': None,
            'imap_spam_box': None,
            'headers_regex': None,
            'smtp_user': None,
            'smtp_pass': None,
            'smtp_host': None
    }

    def init(self, args = None):
      self.found = self.NOTFOUND

      # First parse the configuration file.
      config = ConfigParser.ConfigParser(self.settings)
      home = expanduser("~")
      config.readfp(open(home + '/.filter-check.conf'))

      self.settings['headers'] = config.getboolean("main", "headers")
      self.settings['quiet'] = config.getboolean("main", "quiet")
      self.settings['gtube'] = config.getboolean("main", "gtube")
      self.settings['emailfrom'] = config.get("main", "emailfrom")
      self.settings['sleep'] = config.getfloat("main", "sleep")

      self.settings['sendto'] = config.get("main", "sendto")
      self.settings['sendvia'] = config.get("main", "sendvia")
      
      # Now, overwrite with passed in arguments.
      for key, value in vars(args).iteritems():
          if value is not None:
            setattr(self, key, value)

      # Now, set the smtp and imap variables.
      try:
          self.settings['emailto'] = config.get(self.sendto, "emailto")
          self.settings['imap_user'] = config.get(self.sendto, "imap_user")
          self.settings['imap_pass'] = config.get(self.sendto, "imap_pass")
          self.settings['imap_host'] = config.get(self.sendto, "imap_host")
          self.settings['imap_spam_box'] = config.get(self.sendto, "imap_spam_box")
          self.settings['headers_regex'] = config.get(self.sendto, "headers_regex")

          self.settings['smtp_user'] = config.get(self.sendvia, "smtp_user")
          self.settings['smtp_pass'] = config.get(self.sendvia, "smtp_pass")
          self.settings['smtp_host'] = config.get(self.sendvia, "smtp_host")

      except ConfigParser.NoOptionError, e:
          # Throw a friendlier error 
          self.output("Error, could not find your sendvia or sendto block in the config file.")
          return self.ERROR

      # If debugging, send a message that spamassassin will automatically
      # process as spam.
      if self.settings['gtube'] == True:
          self.msg = "XJS*C4JDBQADN1.NSBN3*2IDNEN*GTUBE-STANDARD-ANTI-UBE-TEST-EMAIL*C.34X"

    def output(self, msg):
        if not self.settings['quiet']:
            print("{0}".format(msg))

    def run(self):
      # Send the message.
      msg = "Subject: {0}\r\nFrom: {1}\r\nTo: {2}\r\n\r\n{3}"
      mail = msg.format(
        self.settings['subject'], 
        self.settings['emailfrom'], 
        self.settings['emailto'], 
        self.settings['msg']
      )
      server = smtplib.SMTP_SSL(self.settings['smtp_host'])
      if self.settings['smtp_user'] and self.settings['smtp_pass']:
        server.login(self.settings['smtp_user'], self.settings['smtp_pass'])
      #server.set_debuglevel(1)
      server.sendmail(self.settings['emailfrom'], self.settings['emailto'], mail)
      self.output("Message sent")
      server.quit()

      # Give the message some time to be delivered.
      self.output("Sleeping.")
      time.sleep(self.settings['sleep'])

      # Login to check for it.
      M = imaplib.IMAP4_SSL(self.settings['imap_host'])
      M.login(self.settings['imap_user'], self.settings['imap_pass'])
      # Uncomment to trouble shoot where the spam box is.
      #print M.namespace()
      #print M.list()
 
      reg = re.compile(self.settings['headers_regex'])

      # Try INBOX first.
      messages = []
      exit_code = 0
      count = M.select()
      if count > 0:
          typ, data = M.search(None, 'Subject', self.settings['subject'])
          messages = data[0]

      if len(messages) > 0:
          self.found = self.INBOX
      else:
          # Try spam box.
          count = M.select(self.settings['imap_spam_box'])
          if count > 0:
              typ, data = M.search(None, 'Subject', self.settings['subject'])
              messages = data[0]
              if len(messages) > 0:
                  self.found = self.SPAMBOX

      if self.found == self.NOTFOUND:
          self.output("Found in: NOT FOUND")
      else:
          if self.found == self.INBOX:
            friendly_location = 'Inbox'
          else:
            friendly_location = 'Spambox'

          self.output("Found in: {0}\n".format(friendly_location))

      # Iterate over each message found
      for num in messages.split():
          typ, data = M.fetch(num, '(RFC822)')
          parser = HeaderParser()
          headers = parser.parsestr(data[0][1])
          for key in headers.keys():
              if self.settings['headers'] == True or reg.match(key):
                  self.output("{0}: {1}".format(key, headers.get(key)))

          M.store(num, '+FLAGS', '\\Deleted')

      M.expunge()
      M.close()
      M.logout()
      return self.found

if __name__ == "__main__":
    sys.exit(main())
