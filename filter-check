#!/usr/bin/python

import smtplib
import sys
import imaplib
import time
import re
import ConfigParser
from email.parser import HeaderParser
from os.path import expanduser
import argparse
from email.Utils import formatdate
from email.utils import make_msgid

def main():
  # Prepare the command line argument parser.
  parser = argparse.ArgumentParser(
    prog = "filter-check", 
    description='Check deliverability to various mail providers. Configuration file is in ~/.filter-check.conf',
    epilog="Exit codes: 0 if message is found in Inbox, 1 if found in spam box, 2 if not delivered, 255 if error."
  )
  parser.add_argument('--sendvia',
    default=None,
    help='the host to relay the email'
  )
  parser.add_argument('--sendto',
    default=None,
    help='the host to send the email'
  )
  parser.add_argument(
    '--quiet', 
    default=None,
    action="store_true",
    help='surpress all output, use exit codes only'
  )
  parser.add_argument('--gtube',
    default=None, action="store_true",
    help='use spamassassin code to identify the message as spam (for debugging)'
  )
  parser.add_argument('--headers',
    default=None, action="store_true",
    help='output full headers, instead of brief headers'
  )
  parser.add_argument('--sleep',
    type=float,
    default=None, help='number of seconds to wait between sending and checking email'
  )
  parser.add_argument('--emailfrom',
    default=None, help='send the test message from this email'
  )
  parser.add_argument('--subject',
    default=None, help='specify the subject for the test message'
  )
  parser.add_argument('--msg',
    default=None, help='specify the body of the test message'
  )
  parser.add_argument('--sendonly',
    default=None,
    action="store_true",
    help="don't fetch the message, only send it and output the message-id sent"
  )
  parser.add_argument('--fetchfrom',
    default=None,
    help="don't send a message, only fetch a message from this host matching the passed messageid"
  )
  parser.add_argument('--messageid',
    default=None,
    help="when using fetchfrom, fetch the messageid specified in this option"
  )
  args = parser.parse_args()

  check = filter_check()
  ret = check.init(args)

  # If there is an error parsing the options, bail.
  if ret is not True:
    return ret

  return check.run()

class filter_check:
  # Constants representing return codes. SUCCESS means either the message
  # was sent successfully or it was retrieved from the INBOX or both.
  SUCCESS = 0
  SPAMBOX = 1
  NOTFOUND = 2
  ERROR = 255

  # Variable holding where the message was found. 
  found = None 

  # Global config object
  config = None

  # Default values go here.
  settings = {
    'sleep': 10,
    'quiet': False,
    'headers': False,
    'gtube': False,
    'subject': 'Meeting next week',
    'msg': "Hi all,\nDon't forget, the next meeting is on Wendesday at 8:00 pm.\n\nSee you there,\njoe",
    'emailfrom': None,
    'sendto': None,
    'sendvia': None,
    'emailto': None,
    'imap_user': None,
    'imap_pass': None,
    'imap_host': None,
    'imap_spam_box': None,
    'headers_regex': 'Subject',
    'smtp_user': None,
    'smtp_pass': None,
    'smtp_host': None,
    'fetchfrom': None,
    'sendonly': False,
    'messageid': None
  }

  # The imap object
  imap = None

  def init(self, args = None):
    self.found = self.NOTFOUND

    # First parse the configuration file.
    self.config = ConfigParser.SafeConfigParser()
    home = expanduser("~")
    self.config.readfp(open(home + '/.filter-check.conf'))

    # These settings may or may not be present in the configuration file.
    # If absent, we use the defaults. Either way, they can be overwritten
    # by the command line arguments below.
    self.set_optional_setting('main', 'headers', vartype = 'boolean');
    self.set_optional_setting('main', 'quiet', vartype = 'boolean');
    self.set_optional_setting('main', 'gtube', vartype = 'boolean');
    self.set_optional_setting('main', 'emailfrom');
    self.set_optional_setting('main', 'sleep', vartype = 'float');
    self.set_optional_setting('main', 'sendto');
    self.set_optional_setting('main', 'sendvia');
    self.set_optional_setting('main', 'sendonly');
    self.set_optional_setting('main', 'fetchfrom');
    self.set_optional_setting('main', 'messageid');

    # Now, overwrite with command line arguments.
    for key, value in vars(args).iteritems():
      if value is not None:
        self.settings[key] = value

    # Now, set the emailto and imap variables, if necessary. These may be required so bail
    # if any of them are not set.

    if self.settings['sendonly'] == False:
        # We need the imap settings since we will be fetching mail.
        try:
          self.settings['imap_user'] = self.config.get(self.settings['sendto'], "imap_user")
          self.settings['imap_pass'] = self.config.get(self.settings['sendto'], "imap_pass")
          self.settings['imap_host'] = self.config.get(self.settings['sendto'], "imap_host")
          self.settings["imap_spam_box"] = self.config.get(self.settings['sendto'], "imap_spam_box")
        except ConfigParser.NoOptionError:
          # Throw a friendlier error.
          self.output("Error, missing one of your imap_ settings in your sendto section.")
          return self.ERROR
        except ConfigParser.NoSectionError as e:
          self.output("Please ensure the your --sendto value is set as a section in your config file.")
          return self.ERROR

    if self.settings['fetchfrom'] == None:
        # We need the emailto setting since we will be sending mail.
        try:
          self.settings['emailto'] = self.config.get(self.settings['sendto'], "emailto")
        except ConfigParser.NoOptionError:
          # Throw a friendlier error.
          self.output("Error, missing emailto setting in your sendto section.")
          return self.ERROR
        except ConfigParser.NoSectionError as e:
          self.output("Please ensure the your --sendto value is set as a section in your config file.")
          return self.ERROR

    # The sentvia should be set to either a section OR to a host (e.g. localhost)
    try:
      self.settings['smtp_host'] = self.config.get(self.settings['sendvia'], "smtp_host")
    except ConfigParser.NoSectionError:
      # If there is no section, let's see if the sendvia value itself
      # seems to be something we can deliver mail to.

      if self.settings['sendvia'] == 'localhost':
        self.settings['smtp_host'] = 'localhost'
        pass

      # Very simple testing...
      ipv4_reg = re.compile('^([0-9]{1,3}\.){3}[0-9]+')
      domain_reg = re.compile('^[a-zA-Z-]+')
      if ipv4_reg.match(self.settings['sendvia']) or domain_reg.match(self.settings['sendvia']):
        self.settings['smtp_host'] = self.settings['sendvia']
        pass

    # Set more optional settings.
    self.set_optional_setting(self.settings['sendto'], "headers_regex")
    self.set_optional_setting(self.settings['sendvia'], "smtp_user")
    self.set_optional_setting(self.settings['sendvia'], "smtp_pass")

    # If debugging, send a message that spamassassin will automatically
    # process as spam
    if self.settings['gtube'] == True:
      self.msg = "XJS*C4JDBQADN1.NSBN3*2IDNEN*GTUBE-STANDARD-ANTI-UBE-TEST-EMAIL*C.34X"

    # Now do some sanity checking. It's possible to have conflicting settings.
    if self.settings['fetchfrom'] and not self.settings['messageid']:
      self.output("Can't fetchfrom without a message id.")
      return self.ERROR

    if self.settings['fetchfrom'] is not None and self.settings['sendonly'] == True:
      self.output("--fetchfrom and --sendonly contradict each other. Please set only one of them.")
      return self.ERROR

    return True

  def set_optional_setting(self, section, key, vartype = 'string'):
    try:
      if vartype == "boolean":
        self.settings[key] = self.config.getboolean(section, key)
      elif vartype == "float":
        self.settings[key] = self.config.getfloat(section, key)
      else:
        self.settings[key] = self.config.get(section, key)

    except ConfigParser.NoOptionError:
      pass
    except ConfigParser.NoSectionError:
      pass

  def output(self, msg):
    if not self.settings['quiet']:
      print("{0}".format(msg))

  def run(self):
    if self.settings['fetchfrom'] == None:
      # Build the message.
      self.settings['messageid'] = make_msgid()
      mail_date = formatdate()
      msg = "Subject: {0}\r\nFrom: {1}\r\nTo: {2}\r\nDate: {3}\r\nMessage-id: {4}\r\n{5}"
      mail = msg.format(
        self.settings['subject'], 
        self.settings['emailfrom'], 
        self.settings['emailto'], 
        mail_date,
        self.settings['messageid'],
        self.settings['msg']
      )

      # Send it.
      try:
        if self.settings['smtp_user'] and self.settings['smtp_pass']:
          smtp = smtplib.SMTP_SSL(self.settings['smtp_host'])
        else:
          smtp = smtplib.SMTP(self.settings['smtp_host'])
      except Exception as e:
        self.output("Could not connect to the smtp host.")
        self.output(e)
        return self.ERROR

      # Only authenticate if we have a user/pass (we don't need one to send
      # via localhost).
      if self.settings['smtp_user'] and self.settings['smtp_pass']:
        smtp.login(self.settings['smtp_user'], self.settings['smtp_pass'])
      #smtp.set_debuglevel(1)
      try:
        smtp.sendmail(self.settings['emailfrom'], self.settings['emailto'], mail)
      except Exception as e:
        self.output("Message delivery was refused.")
        self.output(e)
        return self.ERROR

      smtp.quit()
      self.output("Message sent ({0})".format(mail_date))
      self.output("Message-id: {0}".format(self.settings['messageid']))
      if self.settings['quiet'] == True:
        # In quiet mode, just output the message-id by itself via standard
        # out so it can easily be captured in batch mode.
        print(self.settings['messageid'])
      
    if self.settings['sendonly'] == True:
      # We are done.
      return self.SUCCESS

    # Try to retrieve the message.
    if self.settings['fetchfrom'] is None:
      # Give the message some time to be delivered.
      self.output("Sleeping for {0} seconds.".format(self.settings['sleep']))
      time.sleep(self.settings['sleep'])

    # Login to check for it.
    self.imap = imaplib.IMAP4_SSL(self.settings['imap_host'])
    try:
      self.imap.login(self.settings['imap_user'], self.settings['imap_pass'])
    except Exception as e:
      self.output("Failed to login to IMAP server. Wrong user/pass?")
      return self.ERROR

    # Uncomment to trouble shoot where the spam box is.
    #print self.imap.namespace()
    #print self.imap.list()
 
    messages = self.retrieve_messages()

    reg = re.compile(self.settings['headers_regex'])
    # Iterate over each message found (should only be one)
    for num in messages.split():
      try:
        typ, data = self.imap.fetch(num, '(RFC822)')
      except Exception as e:
        self.output("Failed to fetch the message.")
        self.output(e)
        self.output(messages)
        return self.ERROR
      parser = HeaderParser()
      headers = parser.parsestr(data[0][1])
      for key in headers.keys():
        if self.settings['headers'] == True or reg.match(key):
          self.output("{0}: {1}".format(key, headers.get(key)))
      self.imap.store(num, '+FLAGS', '\\Deleted')

    self.imap.expunge()
    self.imap.close()
    self.imap.logout()
    return self.found

  """
  Given a imap object and a header, get the matching
  message.
  """
  def retrieve_messages(self):
    # Try INBOX first.
    messages = self.search_mailbox() 

    if len(messages) > 0:
      self.found = self.SUCCESS
    else:
      # Try spam box.
      messages = self.search_mailbox(self.settings['imap_spam_box']) 
      if len(messages) > 0:
        self.found = self.SPAMBOX

    if self.found == self.NOTFOUND:
      self.output("Found in: NOT FOUND")
    else:
      if self.found == self.SUCCESS:
        friendly_location = 'Inbox'
      else:
        friendly_location = 'Spambox'

      self.output("Found in: {0}\n".format(friendly_location))

    return messages

  def search_mailbox(self, mailbox = 'Inbox'):
    messages = "" 
    if mailbox == 'Inbox':
      count = self.imap.select()
    else:
      count = self.imap.select(mailbox)

    if count > 0:
      if self.settings["imap_host"] == "imap.mail.yahoo.com":
        # Yahoo IMAP doesn't support searching. bleh. We have to fetch each
        # message and look for our special header.
        typ, data = self.imap.search(None, 'ALL')
        for num in data[0].split():
          typ, data = self.imap.fetch(num, '(RFC822)')
          parser = HeaderParser()
          headers = parser.parsestr(data[0][1])
          for key in headers.keys():
            if key == "Message-id" and headers[key] == self.settings['messageid']:
              messages = num
      else:
        typ, data = self.imap.search(None, '(HEADER Message-id "' + self.settings['messageid'] + '")')
        messages = data[0]

    return messages

if __name__ == "__main__":
  sys.exit(main())
