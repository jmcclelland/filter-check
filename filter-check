#!/usr/bin/python

import smtplib
import sys
import imaplib
import time
import re
import ConfigParser
from email.parser import HeaderParser
from os.path import expanduser
import argparse
import random
from email.Utils import formatdate
from email.utils import make_msgid

def main():
  # Prepare the command line argument parser.
  parser = argparse.ArgumentParser(
    prog = "filter-check", 
    description='Check deliverability to various mail providers. Configuration file is in ~/.filter-check.conf',
    epilog="Exit codes: 0 if message is found in Inbox, 1 if found in spam box, 3 if not delivered, 255 if error."
  )
  parser.add_argument('--sendvia',
    default=None,
    help='the host to relay the email'
  );
  parser.add_argument('--sendto',
    default=None,
    help='the host to send the email'
  );
  parser.add_argument(
    '--quiet', 
    default=None,
    action="store_true",
    help='surpress all output, use exit codes only'
  );
  parser.add_argument('--gtube',
    default=None, action="store_true",
    help='use spamassassin code to identify the message as spam (for debugging)'
  );
  parser.add_argument('--headers',
    default=None, action="store_true",
    help='output full headers, instead of brief headers'
  );
  parser.add_argument('--sleep',
    type=float,
    default=None, help='number of seconds to wait between sending and checking email'
  );
  parser.add_argument('--emailfrom',
    default=None, help='send the test message from this email'
  );
  parser.add_argument('--subject',
    default=None, help='specify the subject for the test message'
  );
  parser.add_argument('--msg',
    default=None, help='specify the body of the test message'
  );
  args = parser.parse_args()

  check = filter_check()
  ret = check.init(args)

  # If there is an error parsing the options, bail.
  if ret is not True:
    return ret

  return check.run()

class filter_check:
  # Constants representing where a message is found.
  INBOX = 0
  SPAMBOX = 1
  NOTFOUND = 3
  ERROR = 255

  # Variable holding where the message was found. 
  found = None 

  # Global config object
  config = None

  # Default values go here.
  settings = {
    'sleep': 10,
    'quiet': False,
    'headers': False,
    'gtube': False,
    'subject': 'Meeting next week',
    'msg': "Hi all,\nDon't forget, the next meeting is on Wendesday at 8:00 pm.\n\nSee you there,\njoe",
    'emailfrom': None,
    'sendto': None,
    'sendvia': None,
    'emailto': None,
    'imap_user': None,
    'imap_pass': None,
    'imap_host': None,
    'imap_spam_box': None,
    'headers_regex': 'Subject',
    'smtp_user': None,
    'smtp_pass': None,
    'smtp_host': None
  }

  # The imap object
  imap = None

  # The header value that will be used to find this message
  x_filter_check = None

  def init(self, args = None):
    self.found = self.NOTFOUND

    # First parse the configuration file.
    self.config = ConfigParser.SafeConfigParser()
    home = expanduser("~")
    self.config.readfp(open(home + '/.filter-check.conf'))

    # These settings may or may not be present in the configuration file.
    # If absent, we use the defaults. Either way, they can be overwritten
    # by the command line arguments below.
    self.set_optional_setting('main', 'headers', vartype = 'boolean');
    self.set_optional_setting('main', 'quiet', vartype = 'boolean');
    self.set_optional_setting('main', 'gtube', vartype = 'boolean');
    self.set_optional_setting('main', 'emailfrom');
    self.set_optional_setting('main', 'sleep', vartype = 'float');
    self.set_optional_setting('main', 'sendto');
    self.set_optional_setting('main', 'sendvia');

    # Now, overwrite with command line arguments.
    for key, value in vars(args).iteritems():
      if value is not None:
        self.settings[key] = value

    # Now, set the smtp and imap variables. These are required so bail
    # if any of them are not set.
    try:
      self.settings['emailto'] = self.config.get(self.settings['sendto'], "emailto")
      self.settings['imap_user'] = self.config.get(self.settings['sendto'], "imap_user")
      self.settings['imap_pass'] = self.config.get(self.settings['sendto'], "imap_pass")
      self.settings['imap_host'] = self.config.get(self.settings['sendto'], "imap_host")
      self.settings["imap_spam_box"] = self.config.get(self.settings['sendto'], "imap_spam_box")
      self.settings['smtp_host'] = self.config.get(self.settings['sendvia'], "smtp_host")

    except ConfigParser.NoOptionError:
      # Throw a friendlier error.
      self.output("Error, missing a required value in your sendto or sendvia section.")
      return self.ERROR
    except ConfigParser.NoSectionError:
      self.output("Please ensure both --sendto and --sendvia values are set as sections in your config file.")
      return self.ERROR

    # Set more optional settings.
    self.set_optional_setting(self.settings['sendto'], "headers_regex")
    self.set_optional_setting(self.settings['sendvia'], "smtp_user")
    self.set_optional_setting(self.settings['sendvia'], "smtp_pass")

    # If debugging, send a message that spamassassin will automatically
    # process as spam
    if self.settings['gtube'] == True:
      self.msg = "XJS*C4JDBQADN1.NSBN3*2IDNEN*GTUBE-STANDARD-ANTI-UBE-TEST-EMAIL*C.34X"

    return True

  def set_optional_setting(self, section, key, vartype = 'string'):
    try:
      if vartype == "boolean":
        self.settings[key] = self.config.getboolean(section, key)
      elif vartype == "float":
        self.settings[key] = self.config.getfloat(section, key)
      else:
        self.settings[key] = self.config.get(section, key)

    except ConfigParser.NoOptionError:
      pass

  def output(self, msg):
    if not self.settings['quiet']:
      print("{0}".format(msg))

  def run(self):
    # Generate a random string and add it to the messave via an invented
    # header so we can find the message via IMAP below.
    rand = random.getrandbits(128)
    self.x_filter_check = "%32x" % rand

    # Build the message.
    msg = "Subject: {0}\r\nFrom: {1}\r\nTo: {2}\r\nDate: {3}\r\nMessage-id: {4}\r\nX-filter-check: {5}\r\n{6}"
    mail = msg.format(
      self.settings['subject'], 
      self.settings['emailfrom'], 
      self.settings['emailto'], 
      formatdate(),
      make_msgid(),
      self.x_filter_check,
      self.settings['msg']
    )

    # Send it.
    try:
      if self.settings['smtp_user'] and self.settings['smtp_pass']:
        smtp = smtplib.SMTP_SSL(self.settings['smtp_host'])
      else:
        smtp = smtplib.SMTP(self.settings['smtp_host'])
    except Exception as e:
      self.output("Could not connect to the smtp host.")
      self.output(e)
      return self.ERROR

    # Only authenticate if we have a user/pass (we don't need one to send
    # via localhost).
    if self.settings['smtp_user'] and self.settings['smtp_pass']:
      smtp.login(self.settings['smtp_user'], self.settings['smtp_pass'])
    #smtp.set_debuglevel(1)
    try:
      smtp.sendmail(self.settings['emailfrom'], self.settings['emailto'], mail)
    except Exception as e:
      self.output("Message delivery was refused.")
      self.output(e)
      return self.ERROR

    self.output("Message sent")
    smtp.quit()

    # Give the message some time to be delivered.
    self.output("Sleeping.")
    time.sleep(self.settings['sleep'])

    # Login to check for it.
    self.imap = imaplib.IMAP4_SSL(self.settings['imap_host'])
    try:
      self.imap.login(self.settings['imap_user'], self.settings['imap_pass'])
    except Exception as e:
      self.output("Failed to login to IMAP server. Wrong user/pass?")
      return self.ERROR

    # Uncomment to trouble shoot where the spam box is.
    #print self.imap.namespace()
    #print self.imap.list()
 
    messages = self.retrieve_messages()

    reg = re.compile(self.settings['headers_regex'])
    # Iterate over each message found (should only be one)
    for num in messages.split():
      try:
        typ, data = self.imap.fetch(num, '(RFC822)')
      except Exception as e:
        self.output("Failed to fetch the message.")
        self.output(e)
        self.output(messages)
        return self.ERROR
      parser = HeaderParser()
      headers = parser.parsestr(data[0][1])
      for key in headers.keys():
        if self.settings['headers'] == True or reg.match(key):
          self.output("{0}: {1}".format(key, headers.get(key)))
      self.imap.store(num, '+FLAGS', '\\Deleted')

    self.imap.expunge()
    self.imap.close()
    self.imap.logout()
    return self.found

  """
  Given a imap object and a header, get the matching
  message.
  """
  def retrieve_messages(self):
    # Try INBOX first.
    messages = self.search_mailbox() 

    if len(messages) > 0:
      self.found = self.INBOX
    else:
      # Try spam box.
      messages = self.search_mailbox(self.settings['imap_spam_box']) 
      if len(messages) > 0:
        self.found = self.SPAMBOX

    if self.found == self.NOTFOUND:
      self.output("Found in: NOT FOUND")
    else:
      if self.found == self.INBOX:
        friendly_location = 'Inbox'
      else:
        friendly_location = 'Spambox'

      self.output("Found in: {0}\n".format(friendly_location))

    return messages

  def search_mailbox(self, mailbox = 'Inbox'):
    messages = "" 
    if mailbox == 'Inbox':
      count = self.imap.select()
    else:
      count = self.imap.select(mailbox)

    if count > 0:
      if self.settings["imap_host"] == "imap.mail.yahoo.com":
        # Yahoo IMAP doesn't support searching. bleh. We have to fetch each
        # message and look for our special header.
        typ, data = self.imap.search(None, 'ALL')
        for num in data[0].split():
          typ, data = self.imap.fetch(num, '(RFC822)')
          parser = HeaderParser()
          headers = parser.parsestr(data[0][1])
          for key in headers.keys():
            if key == "X-filter-check" and headers[key] == self.x_filter_check:
              messages = num
      else:
        typ, data = self.imap.search(None, '(HEADER X-filter-check "' + self.x_filter_check + '")')
        messages = data[0]

    return messages

if __name__ == "__main__":
  sys.exit(main())
